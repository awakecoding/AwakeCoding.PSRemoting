name: Release PowerShell Module

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 2026.1.0) or "latest" for calendar version'
        default: 'latest'
        required: true
        type: string
      skip-psgallery:
        description: 'Skip publishing to PowerShell Gallery'
        required: true
        type: boolean
        default: false
      dry-run:
        description: 'Dry run (simulate release)'
        required: true
        type: boolean
        default: true

permissions:
  contents: write

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-22.04
    outputs:
      package-version: ${{ steps.info.outputs.package-version }}
      skip-psgallery: ${{ steps.info.outputs.skip-psgallery }}
      dry-run: ${{ steps.info.outputs.dry-run }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Package information
        id: info
        shell: pwsh
        run: |
          $IsMasterBranch = ('${{ github.ref_name }}' -eq 'master' -or '${{ github.ref_name }}' -eq 'main')
          $IsTaggedRelease = ('${{ github.event_name }}' -eq 'push' -and '${{ github.ref }}' -match '^refs/tags/v')
          
          try { $SkipPSGallery = [System.Boolean]::Parse('${{ inputs.skip-psgallery }}') } catch { $SkipPSGallery = $false }
          try { $DryRun = [System.Boolean]::Parse('${{ inputs.dry-run }}') } catch { $DryRun = $true }
          
          # Force dry run when not on master/main branch
          if (-Not $IsMasterBranch -And -Not $IsTaggedRelease) {
            $DryRun = $true
          }
          
          # Get version
          $PackageVersion = '${{ inputs.version }}'
          if ($IsTaggedRelease) {
            # Extract version from tag (e.g., v2026.1.0 -> 2026.1.0)
            $PackageVersion = '${{ github.ref_name }}' -replace '^v', ''
          } elseif ([string]::IsNullOrEmpty($PackageVersion) -or $PackageVersion -eq 'latest') {
            # Auto-generate version from date
            $PackageVersion = (Get-Date -Format "yyyy.M.d")
          }
          
          # Validate version format (major.minor.patch)
          if ($PackageVersion -NotMatch '^\d+\.\d+\.\d+$') {
            throw "Invalid version format: $PackageVersion, expected: major.minor.patch (e.g., 2026.1.0)"
          }
          
          echo "package-version=$PackageVersion" >> $env:GITHUB_OUTPUT
          echo "skip-psgallery=$($SkipPSGallery.ToString().ToLower())" >> $env:GITHUB_OUTPUT
          echo "dry-run=$($DryRun.ToString().ToLower())" >> $env:GITHUB_OUTPUT
          
          echo "::notice::Version: $PackageVersion"
          echo "::notice::Skip PSGallery: $SkipPSGallery"
          echo "::notice::Dry Run: $DryRun"

  build:
    name: Build
    needs: preflight
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
        
    - name: Inject version
      shell: pwsh
      run: |
        $version = "${{ needs.preflight.outputs.package-version }}"
        Write-Host "Injecting version: $version"
        
        # Update module manifest
        $manifestPath = Join-Path $env:GITHUB_WORKSPACE 'AwakeCoding.PSRemoting/AwakeCoding.PSRemoting.psd1'
        $content = Get-Content $manifestPath -Raw
        $content = $content -replace "ModuleVersion = '[^']+'", "ModuleVersion = '$version'"
        Set-Content -Path $manifestPath -Value $content -NoNewline
        
        # Update csproj
        $csprojPath = Join-Path $env:GITHUB_WORKSPACE 'src/AwakeCoding.PSRemoting.PowerShell.csproj'
        $xml = [xml](Get-Content $csprojPath)
        
        # Get first PropertyGroup (handle both single element and array cases)
        $propertyGroup = $xml.Project.PropertyGroup
        if ($propertyGroup -is [System.Array]) {
          $propertyGroup = $propertyGroup[0]
        }
        
        # Update or create Version element
        if ($null -eq $propertyGroup.Version) {
          $versionNode = $xml.CreateElement('Version')
          $versionNode.InnerText = $version
          $propertyGroup.AppendChild($versionNode) | Out-Null
        } else {
          $propertyGroup.Version = $version
        }
        
        # Update or create AssemblyVersion element
        if ($null -eq $propertyGroup.AssemblyVersion) {
          $assemblyVersionNode = $xml.CreateElement('AssemblyVersion')
          $assemblyVersionNode.InnerText = "$version.0"
          $propertyGroup.AppendChild($assemblyVersionNode) | Out-Null
        } else {
          $propertyGroup.AssemblyVersion = "$version.0"
        }
        
        # Update or create FileVersion element
        if ($null -eq $propertyGroup.FileVersion) {
          $fileVersionNode = $xml.CreateElement('FileVersion')
          $fileVersionNode.InnerText = "$version.0"
          $propertyGroup.AppendChild($fileVersionNode) | Out-Null
        } else {
          $propertyGroup.FileVersion = "$version.0"
        }
        
        $xml.Save($csprojPath)
        
        Write-Host "Version injected successfully"
        
    - name: Build module
      shell: pwsh
      run: |
        $version = "${{ needs.preflight.outputs.package-version }}"
        Write-Host "Building module version $version..."
        
        & (Join-Path $env:GITHUB_WORKSPACE "build.ps1")
        
    - name: Create NuGet package
      shell: pwsh
      run: |
        # Import helper function
        . "$env:GITHUB_WORKSPACE/scripts/New-ModulePackage.ps1"
        
        $modulePath = Join-Path $env:GITHUB_WORKSPACE 'AwakeCoding.PSRemoting'
        $outputPath = Join-Path $env:GITHUB_WORKSPACE 'package'
        
        Write-Host "Creating NuGet package..."
        $nupkgPath = New-ModulePackage -InputPath $modulePath -OutputPath $outputPath
        
        if (Test-Path $nupkgPath) {
          $nupkgName = Split-Path $nupkgPath -Leaf
          Write-Host "Package created: $nupkgName"
        } else {
          Write-Error "Failed to create NuGet package"
          exit 1
        }
        
    - name: Create checksums
      shell: pwsh
      working-directory: package
      run: |
        # Generate checksums
        $HashPath = 'checksums'
        $Files = Get-ChildItem -File | Where-Object { $_.Name -ne 'checksums' }
        $Files | ForEach-Object {
          $Hash = Get-FileHash -Algorithm SHA256 $_.FullName
          "$($Hash.Hash)  $($_.Name)"
        } | Out-File -FilePath $HashPath -Append -Encoding ASCII
        
        echo "::group::checksums"
        Get-Content $HashPath
        echo "::endgroup::"
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: AwakeCoding.PSRemoting-${{ needs.preflight.outputs.package-version }}
        path: package/
        if-no-files-found: error
        retention-days: 90

  release:
    name: Release
    needs: [preflight, build]
    runs-on: ubuntu-22.04
    
    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: AwakeCoding.PSRemoting-${{ needs.preflight.outputs.package-version }}
        path: package/
        
    - name: Publish to PowerShell Gallery
      shell: pwsh
      env:
        PSGALLERY_API_KEY: ${{ secrets.PSGALLERY_API_KEY }}
      working-directory: package
      run: |
        $SkipPSGallery = [System.Boolean]::Parse('${{ needs.preflight.outputs.skip-psgallery }}')
        $DryRun = [System.Boolean]::Parse('${{ needs.preflight.outputs.dry-run }}')
        
        if ($SkipPSGallery) {
          Write-Host "Skipping PowerShell Gallery publishing (skip-psgallery=true)"
          exit 0
        }
        
        # Find the .nupkg file
        $nupkgFile = Get-ChildItem -Filter "*.nupkg" | Select-Object -First 1
        
        if (-not $nupkgFile) {
          Write-Error "No .nupkg file found in artifacts"
          exit 1
        }
        
        $PushArgs = @(
          'nuget', 'push', $nupkgFile.Name,
          '--api-key', $env:PSGALLERY_API_KEY,
          '--source', 'https://www.powershellgallery.com/',
          '--skip-duplicate', '--no-symbols'
        )
        
        Write-Host "dotnet $($PushArgs -Join ' ')"
        
        if ($DryRun) {
          Write-Host "Dry Run: Skipping PowerShell Gallery publishing"
          Write-Host "Would publish: $($nupkgFile.Name)"
        } else {
          & dotnet $PushArgs
          Write-Host "Module published successfully"
        }
        
    - name: Create GitHub release
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      working-directory: package
      run: |
        $PackageVersion = '${{ needs.preflight.outputs.package-version }}'
        $DryRun = [System.Boolean]::Parse('${{ needs.preflight.outputs.dry-run }}')
        $ReleaseTag = "v$PackageVersion"
        $ReleaseTitle = "AwakeCoding.PSRemoting v${PackageVersion}"
        $Repository = $env:GITHUB_REPOSITORY
        
        if ($DryRun) {
          Write-Host "Dry Run: Skipping GitHub release creation"
          Write-Host "Would create release: $ReleaseTitle ($ReleaseTag)"
          Write-Host "Files to upload:"
          Get-ChildItem -File | Select-Object Name, Length | Format-Table
          exit 0
        }
        
        $ReleaseNotes = @"
        ## AwakeCoding.PSRemoting v${PackageVersion}
        
        ### Installation
        ```powershell
        Install-Module AwakeCoding.PSRemoting -RequiredVersion ${PackageVersion}
        ```
        
        ### Changes
        See [PowerShell Gallery](https://www.powershellgallery.com/packages/AwakeCoding.PSRemoting/${PackageVersion}) for details.
        "@
        
        & gh release create $ReleaseTag --repo $Repository --title $ReleaseTitle --notes $ReleaseNotes ./*
